# PDSA: Requirements-to-Code Traceability Architecture — The Biological Cell Pattern

**PDSA ID:** 2026-02-03-UTC-0835.requirements-to-code-traceability-architecture
**Project:** xpollination-mindspace
**Status:** PLAN (Logic Phase — Q-TRACE-1 to Q-TRACE-6 answered, research continued)
**Created:** 2026-02-03
**Priority:** CRITICAL — Foundational architecture for scalable, traceable software development
**Agent:** PDSA Agent
**Parent PDSA:** 2026-02-02-UTC-1300.mindspace-vision.pdsa.md (Section 13.1, Q16)

---

## MANAGEMENT ABSTRACT

**What:** Design a requirements-to-code traceability architecture based on the biological cell metaphor — decentralized, self-aware components coordinated by cores, enabling resilient growth and clear impact analysis.

**Why:** Functional development works for V1, but changes arrive and we cannot scale. Small adjustments in wrong places fulfill requirements but code degrades with each iteration. We need an architecture where:
- Every piece of code knows its purpose (requirement traceability)
- Changes can be analyzed for impact before implementation
- We know whether to REPLACE an organ or ITERATE it
- The system grows through structured processes, not ad-hoc patches

**Outcome:** An architectural pattern that:
1. Defines the vocabulary: cells, organs, cores, blueprints
2. Maps traditional best practices (Lastenheft/Pflichtenheft) to the cell model
3. Specifies how decentralized cores coordinate without bottleneck
4. Enables requirements-to-code traceability at any scale

**Note:** This is RESEARCH. No solution exists on the market. We are defining new best practice.

---

## Thomas's Vision (Verbatim — 2026-02-03)

### The Problem

> Functional development works for V1, but changes arrive and we cannot scale. Small adjustments in wrong places fulfill requirements but code gets worse with each iteration.

### The Solution Pattern — Biological Cells

> Small self-aware cells (aware of their functionality). Cells operate together, guided by a core. Like photosynthesis: many cells in different functions, a core coordinates individual organs. Sugar from sun energy is not random — it is a DESIGN, a BLUEPRINT followed during construction. Result: harmony, not chaos.

### Traditional Best Practice Structure

> Lastenheft (requirements spec), Pflichtenheft (functional spec), Design for implementation, Specific designs for breakdown of objects/"organs" and how they fit together.

### The Architecture

> A CORE that knows how requirements connect to implementation. OPERATIONS CORES for specific requirement versions (e.g., Pflichtenheft V1.4). Operations cores know how implementations work together. DECENTRALIZED CORES do the actual work (not centralized brain — that is a bottleneck, context too much). Decentralized brains aware of: "how to produce certain outcome from certain defined input". Result: resilient cells that can grow through new requirement processes. We know if we need to REPLACE an organ (core + sub-processes) or ITERATE it. We always know how to fulfill the requirement.

### Key Insight

> This is bigger than a linking mechanism. It is a full process architecture.

---

## PLAN

### TRIVIUM APPROACH

This PDSA follows the Trivium Method (Vision PDSA Section 2):
- **GRAMMAR:** Define the concepts, vocabulary, structure — what ARE these things?
- **LOGIC:** How do the pieces connect? What are the relationships? Test for contradictions.
- **RHETORIC:** How do we communicate and implement this?

---

## GRAMMAR PHASE: Defining the Vocabulary

### 1. The Biological Cell Metaphor

Thomas's metaphor maps biological systems to software architecture. Let's define each concept precisely.

#### 1.1 Cell

**Biological:** The smallest unit of life. Self-contained. Has a membrane (boundary), nucleus (control), and performs specific functions. Aware of its inputs (nutrients) and outputs (products).

**Software equivalent:** A self-contained code unit that:
- Has clear boundaries (interface/API)
- Contains its own "knowledge" of what it does (metadata, DoR/DoD)
- Performs a specific function
- Knows its inputs and outputs
- Is aware of its purpose (which requirement it fulfills)

**Candidate implementations:**
- A function with metadata annotations
- A module with a manifest file
- A microservice with a contract
- A class with documentation linking to requirements

#### 1.2 Organ

**Biological:** A collection of cells working together for a higher-level function (heart pumps blood, lungs exchange gases). Organs are replaceable units — you can transplant a heart.

**Software equivalent:** A coherent group of cells (code units) that together fulfill a capability:
- A feature module
- A bounded context (DDD)
- A subsystem
- An "aggregate" of related functionality

**Key property:** An organ can be REPLACED or ITERATED as a unit. If requirements change significantly, we replace the organ. If requirements evolve slightly, we iterate its cells.

#### 1.3 Core

**Biological:** The coordinating intelligence. In a cell, the nucleus contains DNA (the blueprint). In an organism, the brain/nervous system coordinates organs.

**Software equivalent:** The component that:
- Holds the "blueprint" (requirements → design → implementation mapping)
- Coordinates cells and organs
- Knows how pieces fit together
- Does NOT do the work itself — it orchestrates

**Thomas's insight: DECENTRALIZED cores.** Not one central brain (bottleneck, context overflow), but multiple cores at different levels:

```
                    ┌─────────────────┐
                    │   MASTER CORE   │  ← Knows: Lastenheft (what the system must do)
                    │  (Requirements) │     Links to: Operations Cores
                    └────────┬────────┘
                             │
            ┌────────────────┼────────────────┐
            │                │                │
   ┌────────▼────────┐ ┌─────▼─────┐ ┌────────▼────────┐
   │ OPERATIONS CORE │ │ OPS CORE  │ │ OPERATIONS CORE │
   │ Pflichtenheft   │ │ V1.4      │ │ Feature X       │
   │ V1.0            │ │           │ │                 │
   └────────┬────────┘ └─────┬─────┘ └────────┬────────┘
            │                │                │
            │         ┌──────┴──────┐         │
            │         │             │         │
   ┌────────▼───┐ ┌───▼────┐ ┌─────▼───┐ ┌───▼────────┐
   │ ORGAN CORE │ │ ORGAN  │ │ ORGAN   │ │ ORGAN CORE │
   │ Auth       │ │ CORE   │ │ CORE    │ │ Reporting  │
   │            │ │ Data   │ │ UI      │ │            │
   └─────┬──────┘ └───┬────┘ └────┬────┘ └─────┬──────┘
         │            │           │            │
      [cells]      [cells]     [cells]      [cells]
```

#### 1.4 Blueprint (DNA)

**Biological:** DNA is the instruction set. It doesn't do the work — it defines HOW to build and operate. Every cell contains the full blueprint but only expresses relevant parts.

**Software equivalent:** The requirements-to-implementation mapping:
- Lastenheft → Pflichtenheft → Design → Code
- Each level is a "blueprint" for the next
- The blueprint is TRACEABLE — you can follow the chain in either direction

**Key insight:** The blueprint is not just documentation. It is ACTIVE — it guides construction and enables impact analysis.

#### 1.5 Photosynthesis Analogy

Thomas used photosynthesis as an example: "Sugar from sun energy is not random — it is a DESIGN, a BLUEPRINT followed during construction."

**Mapping:**
- **Sun energy** = Input (user requirements, external triggers)
- **Sugar** = Output (working software, fulfilled requirements)
- **Photosynthesis process** = The transformation (development process)
- **Chloroplast** = The organ that performs photosynthesis (a feature module)
- **Chlorophyll cells** = The cells that do the actual work (code units)
- **DNA blueprint** = The instructions that define HOW to convert sun to sugar (requirements → design → code)

The result is NOT random. It is DESIGNED. Harmony, not chaos.

### 2. Traditional Best Practice Mapping

Thomas referenced German engineering documentation standards. Let's map them to the cell model.

#### 2.1 Lastenheft (Requirements Specification)

**Definition:** "What the customer wants" — business requirements, user stories, acceptance criteria from the customer's perspective.

**Cell model mapping:** The MASTER CORE's knowledge. The highest-level blueprint.

**Contains:**
- Business goals
- User requirements
- Acceptance criteria
- Constraints
- NOT how to build it — just what is needed

#### 2.2 Pflichtenheft (Functional Specification)

**Definition:** "What the system will do" — the supplier's response to the Lastenheft. Technical requirements, system behavior, interfaces.

**Cell model mapping:** OPERATIONS CORES. Each Pflichtenheft version is an operations core.

**Contains:**
- System requirements derived from Lastenheft
- Functional specifications
- Interface definitions
- Technical constraints
- Traceability to Lastenheft items

**Key insight:** Pflichtenheft is VERSIONED. V1.0, V1.4, V2.0. Each version is a snapshot of "how we fulfill the Lastenheft at this point."

#### 2.3 Design Documents

**Definition:** Technical designs that specify HOW to build what the Pflichtenheft requires.

**Cell model mapping:** ORGAN CORES. Each organ (subsystem, feature) has a design that specifies its cells.

**Contains:**
- Architecture decisions
- Component breakdown
- Interface contracts
- Data models
- Traceability to Pflichtenheft items

#### 2.4 Implementation (Code)

**Definition:** The actual code that realizes the design.

**Cell model mapping:** CELLS. The smallest units of implementation.

**Contains:**
- Source code
- Tests
- Metadata linking back to Design → Pflichtenheft → Lastenheft

### 3. The Traceability Chain

```
Lastenheft (L)          "Customer wants feature X"
     │
     │ traces to
     ▼
Pflichtenheft (P)       "System will do X via components A, B, C"
     │
     │ traces to
     ▼
Design (D)              "Component A is built with modules α, β"
     │
     │ traces to
     ▼
Code (C)                "Module α is implemented in files x.ts, y.ts"
     │
     │ traces to
     ▼
Tests (T)               "x.test.ts verifies module α meets design"
```

**Bidirectional traceability:**
- Forward: L → P → D → C → T (requirements to tests)
- Backward: T → C → D → P → L (code to requirements)

**Impact analysis:** When L changes, follow the chain to find all affected P, D, C, T.

### 4. Vocabulary Summary

| Term | Biological | Software | Level |
|------|------------|----------|-------|
| **Cell** | Smallest unit of life | Code unit with self-awareness (function, module, class) | Lowest |
| **Organ** | Group of cells for a function | Feature/subsystem/bounded context | Middle |
| **Core** | Coordinating intelligence | Component holding blueprint, orchestrating | Meta |
| **Master Core** | Brain/DNA | Lastenheft — what system must do | Highest |
| **Operations Core** | Organ-level control | Pflichtenheft version — how we fulfill it | High |
| **Organ Core** | Cell-level control | Design — how organ is built | Middle |
| **Blueprint** | DNA instructions | Requirements → Design → Code chain | Cross-cutting |
| **Decentralized** | No single brain | Multiple cores at levels, no bottleneck | Architecture |

---

## LOGIC PHASE: How the Pieces Connect

### 5. Core Hierarchy and Responsibilities

#### 5.1 Master Core (Lastenheft Level)

**Responsibilities:**
- Holds the "what" — business requirements
- Links to all Operations Cores (Pflichtenheft versions)
- Does NOT know implementation details
- Enables: "What requirements exist? Which are fulfilled?"

**Questions it can answer:**
- What does the customer need?
- Which Pflichtenheft versions address which requirements?
- What is the coverage of requirements across versions?

#### 5.2 Operations Core (Pflichtenheft Level)

**Responsibilities:**
- Holds the "how at system level" — functional specifications
- Links UP to Lastenheft items it fulfills
- Links DOWN to Organ Cores it uses
- Knows which organs work together for this version

**Questions it can answer:**
- How does this version fulfill requirement L-123?
- Which organs are involved in feature X?
- What is the impact if requirement L-123 changes?

#### 5.3 Organ Core (Design Level)

**Responsibilities:**
- Holds the "how at component level" — technical design
- Links UP to Pflichtenheft items it fulfills
- Links DOWN to Cells (code) it contains
- Knows how cells interact within the organ

**Questions it can answer:**
- How is this feature built?
- Which code files implement this design?
- Can this organ be replaced or must it be iterated?

#### 5.4 Cells (Code Level)

**Responsibilities:**
- DO the actual work — implementation
- Link UP to Design item they fulfill
- Are SELF-AWARE — know their purpose, inputs, outputs
- Contain tests that verify they work correctly

**Questions they can answer:**
- What requirement does this code fulfill?
- What are my inputs and outputs?
- Am I working correctly? (tests)

### 6. The Decentralization Principle

**Why NOT a centralized brain?**

Thomas: "Not centralized brain — that is a bottleneck, context too much."

A single orchestrator that knows EVERYTHING would:
- Become a bottleneck (all decisions route through it)
- Have too much context (cannot fit in working memory)
- Be a single point of failure
- Not scale

**The decentralized alternative:**

Each core knows ONLY what it needs:
- Master Core: requirements, links to operations cores
- Operations Core: specifications for THIS version, links up and down
- Organ Core: design for THIS organ, links up and down
- Cell: implementation for THIS function, links up

**Coordination without centralization:**
- Cores communicate through well-defined interfaces
- Each core can operate independently with its local context
- Impact analysis traverses the hierarchy — no single component needs full picture
- Like the nervous system: local reflexes + spinal cord + brain stem + cortex

### 7. Replace vs. Iterate Decision

Thomas: "We know if we need to REPLACE an organ (core + sub-processes) or ITERATE it."

**When to ITERATE (evolve existing):**
- Requirement change is small
- Existing design still valid
- Cells can be modified to meet new requirement
- Impact is contained within the organ

**When to REPLACE (transplant new):**
- Requirement change is fundamental
- Existing design no longer fits
- Would require changing too many cells
- Better to build new organ and swap

**How the architecture enables this decision:**

1. Trace requirement change to affected Pflichtenheft items
2. Trace to affected Organ Cores
3. Assess: How many cells affected? How deep is the change?
4. If > threshold → REPLACE organ
5. If < threshold → ITERATE cells

**The threshold is a design decision** — it depends on:
- Complexity of the organ
- Cost of replacement vs. iteration
- Risk of accumulating technical debt

### 8. Self-Awareness at Each Level

Thomas: "Decentralized brains aware of: how to produce certain outcome from certain defined input."

Each level must be self-aware:

| Level | Self-Awareness | Expressed As |
|-------|---------------|--------------|
| Master Core | Knows all requirements | Lastenheft document + index |
| Operations Core | Knows specifications + which organs | Pflichtenheft + organ registry |
| Organ Core | Knows design + which cells | Design doc + cell manifest |
| Cell | Knows purpose + inputs/outputs | Code metadata + DoR/DoD |

**How cells express self-awareness:**

```typescript
/**
 * @requirement P-1.4.3 "User can reset password via email"
 * @design D-AUTH-007 "Password reset flow"
 * @inputs { email: string }
 * @outputs { success: boolean, token?: string }
 */
export async function initiatePasswordReset(email: string): Promise<ResetResult> {
  // implementation
}
```

Or via manifest:

```yaml
# auth/password-reset/manifest.yaml
cell_id: auth-password-reset
requirement_ref: P-1.4.3
design_ref: D-AUTH-007
inputs:
  - name: email
    type: string
outputs:
  - name: success
    type: boolean
  - name: token
    type: string
    optional: true
tests:
  - auth/password-reset/password-reset.test.ts
```

### 9. Relationship to Mindspace

How does this architecture connect to the mindspace we're building?

| Cell Architecture | Mindspace Equivalent |
|------------------|---------------------|
| Master Core | Project root node |
| Operations Core | Requirement nodes |
| Organ Core | Feature/Design nodes |
| Cell | Task nodes |
| Blueprint chain | pdsa_ref links + input/output contracts |
| Self-awareness | DoR/DoD on each node |

**The mindspace IS the blueprint visualization.** Each node in the mindspace is a core or cell. The graph structure IS the traceability chain. Impact analysis IS graph traversal.

---

## RHETORIC PHASE: Communication and Implementation

### 10. How to Communicate This Architecture

#### 10.1 The Elevator Pitch

"We build software like biology builds organisms. Small self-aware cells know their purpose. Organs group cells for features. Cores coordinate without bottleneck. Every piece traces back to requirements. When requirements change, we know exactly what to update — and whether to evolve or replace."

#### 10.2 The Visual

```
┌─────────────────────────────────────────────────────────────────┐
│                         MASTER CORE                              │
│                    (Lastenheft / What)                          │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐               │
│  │ Req L-1 │ │ Req L-2 │ │ Req L-3 │ │ Req L-4 │               │
│  └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘               │
└───────┼──────────┼──────────┼──────────┼────────────────────────┘
        │          │          │          │
        ▼          ▼          ▼          ▼
┌─────────────────────────────────────────────────────────────────┐
│                      OPERATIONS CORES                            │
│                  (Pflichtenheft / How-System)                   │
│  ┌──────────────┐        ┌──────────────┐                       │
│  │ Pflicht V1.0 │        │ Pflicht V2.0 │                       │
│  │ fulfills:    │        │ fulfills:    │                       │
│  │ L-1, L-2     │        │ L-1, L-2, L-3│                       │
│  └──────┬───────┘        └──────┬───────┘                       │
└─────────┼───────────────────────┼───────────────────────────────┘
          │                       │
          ▼                       ▼
┌─────────────────────────────────────────────────────────────────┐
│                        ORGAN CORES                               │
│                    (Design / How-Component)                      │
│  ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐                   │
│  │ Auth   │ │ Data   │ │ UI     │ │ Report │                   │
│  │ Organ  │ │ Organ  │ │ Organ  │ │ Organ  │                   │
│  └───┬────┘ └───┬────┘ └───┬────┘ └───┬────┘                   │
└──────┼──────────┼──────────┼──────────┼─────────────────────────┘
       │          │          │          │
       ▼          ▼          ▼          ▼
┌─────────────────────────────────────────────────────────────────┐
│                          CELLS                                   │
│                    (Code / Implementation)                       │
│  ┌──┐┌──┐┌──┐  ┌──┐┌──┐┌──┐  ┌──┐┌──┐┌──┐  ┌──┐┌──┐┌──┐       │
│  │C1││C2││C3│  │C4││C5││C6│  │C7││C8││C9│  │CA││CB││CC│       │
│  └──┘└──┘└──┘  └──┘└──┘└──┘  └──┘└──┘└──┘  └──┘└──┘└──┘       │
└─────────────────────────────────────────────────────────────────┘
```

### 11. Implementation Strategy

#### 11.1 Phase 1: Metadata Infrastructure

Before we can have self-aware cells, we need a way to express self-awareness:

1. **Define cell manifest schema** — YAML/JSON that captures:
   - Cell ID
   - Requirement references (up-links)
   - Design references (up-links)
   - Inputs and outputs
   - Test references

2. **Define core registry schema** — How cores track their children:
   - Organ Core: list of cells
   - Operations Core: list of organs
   - Master Core: list of operations cores

3. **Define link format** — How references work:
   - Same pattern as dual-links (git URL + local path)
   - Bidirectional: up-link in cell, down-link in core

#### 11.2 Phase 2: Tooling

1. **Traceability analyzer** — Tool that:
   - Reads all manifests
   - Builds the full graph
   - Detects gaps (code without requirement link)
   - Reports coverage

2. **Impact analyzer** — Tool that:
   - Takes a requirement change
   - Traverses graph to find affected code
   - Reports: which organs, which cells, how deep

3. **Replace-or-iterate advisor** — Tool that:
   - Analyzes impact scope
   - Recommends replace vs. iterate based on threshold

#### 11.3 Phase 3: Integration with Mindspace

1. **Import manifests as nodes** — Cell manifests become task nodes
2. **Import cores as group nodes** — Core registries become group nodes
3. **Links become edges** — Requirement refs become graph edges
4. **Impact analysis becomes graph traversal** — MCP tool for impact queries

### 12. Thomas's Answers to Open Questions (Verbatim — 2026-02-03)

#### Additional Requirement from Thomas

> "Add test coverage to requirements. We need to ensure requirements are tested."

**Implication:** The traceability chain must include tests as first-class citizens, not just as verification. Requirements → Tests is a direct link, not just Requirements → Code → Tests.

#### Q-TRACE-1: Manifest Format

> "Cells have data and function in it. So it needs to be self-aware and described in a method that can be read by cell. Like DNA. Investigate options."

**Thomas's direction:** The manifest must be INSIDE the cell, readable BY the cell — not external metadata. Like DNA is inside every cell.

#### Q-TRACE-2: Cross-Organ Dependencies

> "See Q-TRACE-1, I think they are interrelated. You are thinking already on the same lines of thought. Continue and propose options."

**Thomas's direction:** Same self-description mechanism handles cross-organ dependencies. If a cell can describe itself, it can describe its dependencies.

#### Q-TRACE-3: Replace vs. Iterate Threshold

> "We need no automation here. During implementation the agent who plans the impact will evaluate best option moving forward."

**Thomas's direction:** No automated threshold. Human/agent judgment during planning phase. The architecture provides the DATA for the decision; the decision itself is made by the planning agent.

#### Q-TRACE-4: Versioning

> "Yes definitely. We have a direct link and can see what evolves, also what gets removed so we know what code is needed and in use. Not only test coverage as a KPI, we have a very good reflection on the whole project (self-reflected projects! by system design)"

**Thomas's direction:** Full versioning with removal tracking. This enables:
- Knowing what code is needed (in use)
- Knowing what code is obsolete (removed requirements)
- **Self-reflected projects** — the project knows itself by design

#### Q-TRACE-5: Git Integration

> "Git is like a blockchain. We have every mutation in there and can use that when we know how it's linked. So ensure that self-reflection includes the git capabilities so we can harness it."

**Thomas's direction:** Git as immutable mutation log (like blockchain). Every change is recorded. Self-reflection must integrate with git history to harness the full mutation chain.

#### Q-TRACE-6: Bootstrap

> "That is then the job of the agent who plans the development."

**Thomas's direction:** Bootstrap is a planning task, not an automated migration. The planning agent decides how to add manifests to existing code.

---

## CONTINUED RESEARCH: DNA-Like Self-Description

### 13. The DNA Metaphor Deep Dive

Thomas said: "Like DNA. Investigate options."

#### 13.1 How DNA Works in Biology

DNA is the **self-description mechanism** of biological cells:

1. **Location:** DNA is INSIDE the cell (nucleus), not external documentation
2. **Format:** A structured language (ATCG base pairs) that encodes instructions
3. **Self-reading:** The cell has machinery (ribosomes) to READ its own DNA
4. **Expression:** Only relevant parts are "expressed" (transcribed) at any time
5. **Replication:** DNA copies itself when the cell divides
6. **Mutation tracking:** Errors/changes in DNA are passed to descendants

#### 13.2 Translating to Software Cells

| DNA Concept | Software Equivalent | Implementation |
|-------------|---------------------|----------------|
| DNA inside cell | Manifest inside code unit | Embedded metadata, not external file |
| ATCG language | Structured schema | Typed annotations or embedded YAML/JSON |
| Ribosomes read DNA | Runtime/tooling reads manifest | Reflection API, static analysis |
| Gene expression | Conditional behavior | Feature flags, configuration |
| Replication | Code copying/forking | Git clone, module extraction |
| Mutation tracking | Change history | Git commits linked to requirements |

#### 13.3 Options for "DNA Inside the Cell"

**Option A: Inline Annotations (JSDoc/TSDoc style)**

```typescript
/**
 * @dna
 * @cell-id auth-password-reset
 * @requirement L-42 "Users can reset passwords"
 * @pflichtenheft P-1.4.3 "Password reset via email"
 * @design D-AUTH-007
 * @inputs email: string
 * @outputs success: boolean, token?: string
 * @tests ./password-reset.test.ts
 * @depends-on data-user-lookup, email-sender
 */
export async function initiatePasswordReset(email: string): Promise<ResetResult> {
  // The cell's function
}
```

**Pros:**
- DNA is literally inside the code
- Tooling can parse (TypeScript compiler API, JSDoc parsers)
- Visible when reading code
- Survives refactoring (moves with the function)

**Cons:**
- Verbose
- Language-specific
- Not easily queryable without parsing

**Option B: Co-located Manifest File**

```
auth/
├── password-reset/
│   ├── index.ts           # The cell's code
│   ├── dna.yaml           # The cell's DNA
│   └── password-reset.test.ts
```

```yaml
# auth/password-reset/dna.yaml
cell_id: auth-password-reset
requirement: L-42
pflichtenheft: P-1.4.3
design: D-AUTH-007
inputs:
  - name: email
    type: string
outputs:
  - name: success
    type: boolean
  - name: token
    type: string
    optional: true
tests:
  - password-reset.test.ts
depends_on:
  - cell: data-user-lookup
    organ: data
  - cell: email-sender
    organ: notifications
```

**Pros:**
- Structured, easily queryable
- Language-agnostic
- Can be validated against schema
- Tooling can aggregate all dna.yaml files

**Cons:**
- Separate from code (could drift)
- Must maintain discipline to keep in sync

**Option C: Hybrid — Minimal Inline + External Detail**

```typescript
// Inline: minimal DNA pointer
/** @dna auth-password-reset */
export async function initiatePasswordReset(email: string): Promise<ResetResult> {
  // ...
}
```

```yaml
# Central DNA registry or co-located dna.yaml
cells:
  auth-password-reset:
    requirement: L-42
    pflichtenheft: P-1.4.3
    design: D-AUTH-007
    # ... full details
```

**Pros:**
- Code stays clean
- Full details queryable
- Inline tag prevents drift (linter can check)

**Cons:**
- Two places to maintain
- Indirection

#### 13.4 Recommended Approach: Option A with Tooling

Thomas said the cell must be able to "read" its DNA. This suggests:

1. **Inline annotations** (Option A) — DNA is truly inside the cell
2. **Static analysis tooling** — extracts DNA from annotations, builds registry
3. **Runtime reflection** (optional) — cell can query its own DNA at runtime

```typescript
// The cell contains its DNA
/** @dna { "cell": "auth-password-reset", "req": "L-42", ... } */
export async function initiatePasswordReset(email: string): Promise<ResetResult> {
  // Cell can read its own DNA at runtime if needed
  const myDNA = getDNA(initiatePasswordReset);
  console.log(`Fulfilling requirement ${myDNA.req}`);
}
```

**Tooling extracts and aggregates:**
```
$ dna-analyzer scan ./src
Found 47 cells with DNA annotations
Building traceability graph...
Coverage: 42/50 requirements have implementing cells (84%)
Gaps: L-12, L-23, L-31, L-44, L-49, L-50, L-51, L-52 have no cells
```

---

## CONTINUED RESEARCH: Self-Reflected Projects

### 14. The Self-Reflected Project Concept

Thomas introduced a powerful concept: **"Self-reflected projects! By system design."**

#### 14.1 What is a Self-Reflected Project?

A self-reflected project KNOWS ITSELF:
- Knows what requirements it fulfills
- Knows what code implements each requirement
- Knows what tests verify each requirement
- Knows what is in use vs. obsolete
- Knows the impact of any change
- Knows its own history (via git)

This is NOT external documentation ABOUT the project. It is the project's **intrinsic self-knowledge**.

#### 14.2 The Mirror Analogy

A self-reflected project is like looking in a mirror:
- The project can "see" itself
- It knows its own structure
- It knows what's working and what's missing
- Changes are immediately visible

Traditional projects are like working in the dark:
- Documentation is external and often stale
- Impact analysis requires manual investigation
- Gaps are discovered late

#### 14.3 How Self-Reflection is Achieved

| Aspect | Traditional Project | Self-Reflected Project |
|--------|--------------------|-----------------------|
| Requirements | External doc (Word, Confluence) | Embedded in project (Lastenheft nodes) |
| Traceability | Manual cross-references | Automatic via DNA annotations |
| Coverage | Calculated manually | Computed from DNA graph |
| Impact analysis | Human investigation | Graph traversal query |
| Obsolete code | Unknown until audit | Known (no requirement links) |
| Test coverage | Line coverage only | Requirement coverage |
| History | Git log (unstructured) | Git + DNA = structured mutations |

#### 14.4 Self-Reflection Queries

A self-reflected project can answer:

```
Q: What requirements are not yet implemented?
A: Graph query: requirements with no cell links

Q: What code has no purpose?
A: Graph query: cells with no requirement links

Q: What is the impact of changing requirement L-42?
A: Graph traversal: L-42 → P-items → D-items → Cells → Tests

Q: What tests verify requirement L-42?
A: Graph query: tests linked to cells linked to L-42

Q: What changed between V1.0 and V1.4?
A: Git diff + DNA diff: which cells added/removed/modified

Q: Is this code still needed?
A: Check if requirement still exists and is active
```

---

## CONTINUED RESEARCH: Git as Blockchain

### 15. Git as Immutable Mutation Log

Thomas said: **"Git is like a blockchain. We have every mutation in there."**

#### 15.1 The Blockchain Analogy

| Blockchain | Git |
|------------|-----|
| Block | Commit |
| Chain | Commit history (parent links) |
| Hash | Commit SHA |
| Immutability | Once committed, history is preserved |
| Distributed | Every clone has full history |
| Consensus | Merge/rebase resolves conflicts |

Git IS a blockchain for code mutations. Every change is:
- Recorded (commit)
- Hashed (SHA)
- Chained (parent commit)
- Immutable (can't change without changing hash)
- Distributed (every clone has it)

#### 15.2 Harnessing Git for Self-Reflection

**Current state:** Git tracks WHAT changed (files, lines) but not WHY (requirements).

**Enhanced state:** With DNA annotations, git tracks:
- WHAT changed (files, lines)
- WHICH cells changed (DNA identifiers)
- WHY it changed (requirement links in DNA)
- IMPACT (graph traversal from changed cells)

#### 15.3 Structured Commit Messages

To fully harness git-as-blockchain, commits should reference DNA:

```
feat(auth-password-reset): implement email verification

DNA: auth-password-reset
Requirement: L-42
Pflichtenheft: P-1.4.3
Design: D-AUTH-007

- Added email verification step
- Updated tests for new flow
```

Or structured footer:

```
feat: implement password reset email verification

Implements requirement L-42 via cell auth-password-reset.

DNA-CELL: auth-password-reset
DNA-REQ: L-42
DNA-TEST: password-reset.test.ts
```

#### 15.4 Git History Queries with DNA

```bash
# Find all commits that modified cells for requirement L-42
$ git log --all --grep="DNA-REQ: L-42"

# Find all commits that touched a specific cell
$ git log --all -- "src/auth/password-reset/**"

# With DNA tooling:
$ dna-git history --requirement L-42
Commits affecting L-42:
  abc123 (2026-02-01): Initial implementation
  def456 (2026-02-02): Added email verification
  ghi789 (2026-02-03): Fixed edge case
```

#### 15.5 Mutation Tracking for Self-Reflection

The combination of DNA + Git enables:

1. **Requirement lifecycle tracking:**
   - When was L-42 first implemented? (first commit with DNA-REQ: L-42)
   - How has L-42's implementation evolved? (all commits with DNA-REQ: L-42)
   - Is L-42 still active? (current DNA graph includes L-42)

2. **Code lifecycle tracking:**
   - When was this cell created? (first commit with this DNA-CELL)
   - Why was it created? (DNA-REQ in that commit)
   - Has it been modified? (subsequent commits)
   - Is it still needed? (DNA links to active requirements)

3. **Removal tracking:**
   - When was a requirement removed? (commit that removes it from Lastenheft)
   - What code became orphaned? (cells that linked to removed requirement)
   - Was orphaned code cleaned up? (commits removing those cells)

---

## CONTINUED RESEARCH: Enhanced Traceability Chain

### 16. Updated Traceability Chain with Test Coverage

Thomas added: **"Add test coverage to requirements."**

#### 16.1 Original Chain

```
Lastenheft → Pflichtenheft → Design → Code → Tests
```

#### 16.2 Enhanced Chain with Direct Test Links

```
                    Lastenheft (L)
                         │
            ┌────────────┼────────────┐
            │            │            │
            ▼            ▼            ▼
    Pflichtenheft    [direct]    Test Specs
         (P)          link           (TS)
            │            │            │
            ▼            │            │
        Design           │            │
          (D)            │            │
            │            │            │
            ▼            │            │
         Code ───────────┘            │
          (C)                         │
            │                         │
            ▼                         │
    Unit Tests ◄──────────────────────┘
         (T)
```

**Key changes:**
1. **Requirements link directly to Test Specs** — What must be tested for this requirement?
2. **Test Specs link to Unit Tests** — Which tests verify this spec?
3. **Unit Tests link to Code** — Which code does this test exercise?
4. **Complete loop:** L → TS → T → C → D → P → L

#### 16.3 Test Coverage as First-Class Metric

| Metric | Definition | Query |
|--------|------------|-------|
| **Requirement Coverage** | % of requirements with at least one test | `count(L with T) / count(L)` |
| **Cell Coverage** | % of cells with at least one test | `count(C with T) / count(C)` |
| **Test Traceability** | % of tests linked to requirements | `count(T with L) / count(T)` |
| **Orphan Tests** | Tests with no requirement link | `T where no L link` |
| **Untested Requirements** | Requirements with no tests | `L where no T link` |

#### 16.4 DNA Schema Update for Tests

```yaml
# Cell DNA with test coverage
cell_id: auth-password-reset
requirement: L-42
pflichtenheft: P-1.4.3
design: D-AUTH-007
inputs:
  - email: string
outputs:
  - success: boolean
  - token: string (optional)
tests:
  - file: password-reset.test.ts
    verifies:
      - "sends reset email"           # Test case name
      - "generates secure token"
      - "handles invalid email"
    requirement_coverage:
      - L-42.AC1  # Acceptance criterion 1
      - L-42.AC2  # Acceptance criterion 2
```

```yaml
# Test DNA (tests are also cells!)
cell_id: test-auth-password-reset
type: test
tests_cell: auth-password-reset
verifies_requirement: L-42
verifies_acceptance_criteria:
  - L-42.AC1: "User receives email within 1 minute"
  - L-42.AC2: "Token expires after 24 hours"
```

---

## CONTINUED RESEARCH: Cross-Organ Dependencies

### 17. Handling Cross-Organ Dependencies

Thomas confirmed Q-TRACE-2: Same mechanism handles dependencies.

#### 17.1 The Problem

Cell `auth-password-reset` in the Auth organ needs:
- Cell `data-user-lookup` from the Data organ
- Cell `email-sender` from the Notifications organ

How do we express and track this?

#### 17.2 DNA Dependency Declaration

```yaml
# auth/password-reset/dna.yaml
cell_id: auth-password-reset
requirement: L-42
# ... other fields ...

depends_on:
  - cell: data-user-lookup
    organ: data
    interface: UserLookupInterface
    reason: "Need to find user by email"

  - cell: email-sender
    organ: notifications
    interface: EmailSenderInterface
    reason: "Need to send reset email"
```

#### 17.3 Dependency Graph

The DNA creates a dependency graph across organs:

```
Auth Organ                    Data Organ               Notifications Organ
┌─────────────────┐          ┌─────────────────┐      ┌─────────────────┐
│ password-reset  │─────────▶│ user-lookup     │      │ email-sender    │
│                 │          │                 │      │                 │
│ depends_on:     │          │ provides:       │      │ provides:       │
│ - user-lookup   │          │ - UserLookup    │      │ - EmailSender   │
│ - email-sender  │─────────────────────────────────▶│                 │
└─────────────────┘          └─────────────────┘      └─────────────────┘
```

#### 17.4 Impact Analysis Across Organs

When `data-user-lookup` changes:

1. Query: "What depends on `data-user-lookup`?"
2. Result: `auth-password-reset` (and others)
3. Impact: Changes to Data organ affect Auth organ
4. Action: Auth organ tests must be re-run

This is why decentralization matters — the Data organ doesn't need to know about Auth. The dependency is declared in Auth's DNA, and tooling traverses it.

---

### 18. Summary of Thomas's Answers Integration

| Question | Thomas's Answer | Implication |
|----------|-----------------|-------------|
| Q-TRACE-1 | "Like DNA" — self-aware, readable by cell | Inline annotations preferred |
| Q-TRACE-2 | Same mechanism | Dependencies in DNA |
| Q-TRACE-3 | Agent judgment, no automation | Architecture provides data, not decisions |
| Q-TRACE-4 | Yes, track evolution + removal | Self-reflected projects |
| Q-TRACE-5 | Git as blockchain | Structured commits, mutation tracking |
| Q-TRACE-6 | Planning agent's job | Bootstrap is a task, not automation |
| Additional | Test coverage in requirements | Tests are first-class in traceability |

---

### 19. New Open Questions

Based on research, new questions emerge:

1. **Q-TRACE-7:** Which annotation format? (JSDoc-style vs JSON-in-comment vs co-located YAML)

2. **Q-TRACE-8:** How do we validate DNA? (Schema validation, linting, CI checks)

3. **Q-TRACE-9:** How do we visualize the DNA graph? (Mindspace integration? Standalone tool?)

4. **Q-TRACE-10:** How do we handle DNA in non-code artifacts? (Config files, SQL migrations, infrastructure-as-code)

---

## Quality Gates

| Gate | Criteria | Verifier | Status |
|------|----------|----------|--------|
| QG-1 | Thomas's vision captured verbatim | pdsa-agent | PASS |
| QG-2 | Biological metaphor fully mapped to software concepts | pdsa-agent | PASS |
| QG-3 | Traditional best practices (Lastenheft/Pflichtenheft) mapped | pdsa-agent | PASS |
| QG-4 | Core hierarchy defined with responsibilities | pdsa-agent | PASS |
| QG-5 | Decentralization principle explained | pdsa-agent | PASS |
| QG-6 | Replace vs. iterate decision framework defined | pdsa-agent | PASS |
| QG-7 | Self-awareness mechanism specified | pdsa-agent | PASS |
| QG-8 | Connection to mindspace documented | pdsa-agent | PASS |
| QG-9 | Implementation phases outlined | pdsa-agent | PASS |
| QG-10 | Open questions documented for Logic phase | pdsa-agent | PASS |
| QG-11 | Thomas's answers to Q-TRACE-1 through Q-TRACE-6 captured verbatim | pdsa-agent | PASS |
| QG-12 | DNA-like self-description options researched | pdsa-agent | PASS |
| QG-13 | Self-reflected projects concept documented | pdsa-agent | PASS |
| QG-14 | Git-as-blockchain mutation tracking documented | pdsa-agent | PASS |
| QG-15 | Test coverage added to traceability chain | pdsa-agent | PASS |
| QG-16 | Cross-organ dependencies mechanism documented | pdsa-agent | PASS |
| QG-17 | Thomas approves architecture as matching his vision | thomas | PENDING |

---

## DO

*Q-TRACE-1 through Q-TRACE-6 answered. Research continued. Next steps:*

### Completed This Iteration
1. ✅ Thomas's answers captured verbatim (Section 12)
2. ✅ DNA-like self-description researched (Section 13)
3. ✅ Self-reflected projects concept documented (Section 14)
4. ✅ Git-as-blockchain for mutation tracking (Section 15)
5. ✅ Enhanced traceability chain with test coverage (Section 16)
6. ✅ Cross-organ dependencies mechanism (Section 17)

### Pending Thomas Review
1. Review Sections 12-19 for alignment with vision
2. Answer new questions Q-TRACE-7 through Q-TRACE-10
3. Decide on annotation format (JSDoc vs co-located YAML vs hybrid)

### Next Implementation Phase (after approval)
1. Define DNA schema (based on format decision)
2. Prototype DNA parser/analyzer
3. Integrate with mindspace as visualization

---

## STUDY

*Pending implementation.*

---

## ACT

*Pending.*

---

## REFERENCES

### Dual-Links

| Document | Git URL | Local Path |
|----------|---------|------------|
| This PDSA | `https://github.com/PichlerThomas/xpollination-mindspace/blob/main/docs/pdsa/2026-02-03-UTC-0835.requirements-to-code-traceability-architecture.pdsa.md` | `/home/developer/workspaces/github/PichlerThomas/xpollination-mindspace/docs/pdsa/2026-02-03-UTC-0835.requirements-to-code-traceability-architecture.pdsa.md` |
| Vision PDSA | `https://github.com/PichlerThomas/xpollination-mindspace/blob/main/docs/pdsa/2026-02-02-UTC-1300.mindspace-vision.pdsa.md` | `/home/developer/workspaces/github/PichlerThomas/xpollination-mindspace/docs/pdsa/2026-02-02-UTC-1300.mindspace-vision.pdsa.md` |
| MCP Infra PDSA | `https://github.com/PichlerThomas/xpollination-mcp-server/blob/main/docs/pdsa/2026-02-02-UTC-1500.mcp-server-infrastructure-layer.pdsa.md` | `/home/developer/workspaces/github/PichlerThomas/xpollination-mcp-server/docs/pdsa/2026-02-02-UTC-1500.mcp-server-infrastructure-layer.pdsa.md` |

### External References

- **Lastenheft/Pflichtenheft:** German engineering documentation standards (DIN 69901, VDI 2519)
- **Bounded Contexts:** Domain-Driven Design (Eric Evans)
- **Cell Biology:** Cellular organization, organelles, DNA as blueprint
- **Decentralized Systems:** Distributed computing, no single point of failure
